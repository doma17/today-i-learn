# Redis 자료구조를 이용한 사례

### **Sorted Set**을 이용한 사례

1. **리더보드 제작**
  
    게임이나 경쟁 시스템에서 **실시간 랭킹 시스템**을 구현할 때 매우 유용합니다.
    
    ```redis-cli
    ZADD daily-score:250615 100 player:111
    ZADD daily-score:250615 200 player:222
    ZADD daily-score:250615 150 player:333

    ZREVRANGE daily-score:250615 0 2 withscores
    ```

    **ZUNIONSTORE**로 여러 날의 랭킹을 합산하여 **주간/월간 랭킹**을 생성할 수 있습니다. 

2. **최근 접속기록**

    **타임스탬프를 score로 활용**하여 시간 순서대로 정렬된 데이터를 관리할 수 있습니다.

    ```redis-cli
    ZADD search-keyword:111 20250615113301 구글지도
    ZADD search-keyword:111 20250615114502 네이버지도
    ZADD search-keyword:111 20250615115203 카카오맵
    
    # 최근 검색어 5개만 유지 (오래된 것 제거)
    ZREMRANGEBYRANK search-keyword:111 0 -6
    ```

    따라서, **최상위 N개(정책에 따른)의 검색 기록만 저장**할 수 있습니다.
    또한, 파이썬과 같이 **음수 인덱스를 사용**할 수 있기 때문에 다양한 활용이 가능합니다.

3. **Set을 이용한 태그 기능**

    **게시물과 태그 간의 다대다 관계**를 효율적으로 관리할 수 있습니다.

    ```redis-cli
    # 게시물별 태그 저장
    SADD post:47:tags IT REDIS DataStore
    SADD post:22:tags IT Python
    
    # 태그별 게시물 저장 (역방향 인덱싱)
    SADD tag:IT:posts 47 22
    SADD tag:REDIS:posts 47
    SADD tag:Python:posts 22
    ```

    위와 같은 형태의 **Set 구조**로 게시물이 가진 태그를 알 수 있습니다.
    또한 이를 역으로 **태그별 게시물을 관리**한다면, Redis Set의 **교집합, 합집합 기능**을 사용하여 **복합 태그 검색**이 가능합니다.
    
    ```redis-cli
    # IT와 REDIS 태그를 모두 가진 게시물 검색
    SINTER tag:IT:posts tag:REDIS:posts
    ```

4. **랜덤 데이터 추출**

    관계형 DB에서는 랜덤 데이터 추출 시 **ORDER BY RAND()**와 같은 함수를 사용합니다. 하지만, 이러한 함수는 **모든 행을 읽어 임시 테이블에 넣어 정렬**한 다음 랜덤으로 추출하게 됩니다. 즉 데이터가 많을 시에 부하가 많이 가는 **성능상 좋지 않은 작업**입니다.

    하지만 Redis의 **RANDOMKEY** 커맨드는 **O(1)의 시간 복잡도**로 랜덤한 데이터를 추출할 수 있습니다.

    이러한 무작위 키 추출뿐 아니라 **HRANDFIELD, SRANDMEMBER, ZRANDMEMBER** 명령어로 **Hash, Set, Sorted Set** 자료구조에서 랜덤한 아이템을 추출할 수 있습니다. 아이템의 **중복 유무와 개수를 옵션**을 통해 조회할 수 있습니다.

    ```redis-cli
    # Set에서 랜덤 멤버 3개 추출 (중복 없음)
    SRANDMEMBER myset 3
    
    # Sorted Set에서 랜덤 멤버 2개 추출 (점수 포함)
    ZRANDMEMBER myzset 2 WITHSCORES
    ```

### **다양한 카운팅 처리방법**

1. **좋아요 처리**

    Redis **Set을 이용**해서 간단히 처리할 수 있습니다. 게시글의 ID를 포함하는 좋아요 Set을 생성한 후에 유저의 ID를 Set 멤버로 삽입함으로써 **중복을 방지하고 추적**이 가능합니다.

    ```redis-cli
    # 사용자 111이 게시글 47에 좋아요
    SADD post:47:likes 111
    
    # 좋아요 개수 확인
    SCARD post:47:likes
    
    # 사용자가 좋아요를 눌렀는지 확인
    SISMEMBER post:47:likes 111
    
    # 좋아요 취소
    SREM post:47:likes 111
    ```

2. **읽지 않은 메시지 수 카운팅하기**

    앞선 좋아요 처리와 달리 채팅의 내용을 확인하거나 중복된 데이터를 고려할 필요 없이 **추가된 메시지의 개수만 확인**하면 됩니다.
    따라서, **사용자의 ID를 키**로 사용하고, **채널의 ID를 필드**로 활용해 숫자 형태의 메시지 카운트를 관리할 수 있습니다.

    ID가 111인 사용자가 4234 채널에서 새로운 메시지를 수신한다면 다음과 같은 명령어를 쓸 수 있습니다.

    ```redis-cli
    # 메시지 카운트 증가
    HINCRBY user:111:unread channel:4234 1
    
    # 현재 읽지 않은 메시지 수 확인
    HGET user:111:unread channel:4234
    
    # 메시지를 읽었을 때 카운트 감소
    HINCRBY user:111:unread channel:4234 -1
    
    # 모든 채널의 읽지 않은 메시지 수 확인
    HGETALL user:111:unread
    ```

3. **DAU(Daily Active User) 구하기**

    이러한 데이터를 구하기 위해 **로그 기반으로 날마다 배치처리**할 수 있습니다. 하지만 **실시간 데이터 집계가 어렵기** 때문에 비효율적인 방법입니다. 

    앞선 방법처럼 **Set을 활용**해서 유저 ID를 기반으로 저장하는 방법도 있습니다. 하지만 하루에 **1000만 명 이상의 유저가 방문**하는 큰 서비스에서는 권장되지 않습니다. Redis의 **권장 Key당 아이템의 개수는 200~300만개**입니다.

    이러한 상황에서는 Redis의 **비트맵(Bitmap) 구조**를 사용하면 **메모리를 효율적으로 관리**할 수 있습니다. Redis는 string 자료구조에서도 **bit 연산**을 할 수 있습니다. 만약 1천만 명이 넘는 유저의 DAU를 측정한다면 **1천만 개의 비트로 유저를 표현**하며 이는 대략 **1.2MB 크기**입니다. Redis string의 최대 길이는 **512MB**이기에 문제없이 이용자를 카운팅할 수 있습니다.

    만약 2025년 6월 15일에 방문한 유저 id를 구하기 위해서는 키가 **uv:20250615**인 데이터를 만든 뒤에 **접속한 유저 id의 bit를 1로 설정**하면 됩니다. id가 14인 유저가 접근했을 때에는 **오프셋 14를 1로 설정**하면 됩니다.

    ```redis-cli
    # 유저 ID 14가 접속
    SETBIT uv:20250615 14 1
    -> (integer) 0

    # 전체 접속자 수 확인 (DAU)
    BITCOUNT uv:20250615
    -> (integer) 3
    
    # 특정 유저의 접속 여부 확인
    GETBIT uv:20250615 14
    -> (integer) 1
    ```

    만약 게임 서비스에서 **출석 이벤트**를 하여 3일간 매일 출석한 유저에게 보상을 지급한다면 **3일 간의 DAU를 AND 연산**을 통해서 기간 동안 **매일 출석한 유저를 추출**할 수 있습니다.
    
    ```redis-cli
    # 3일 연속 출석한 유저 추출
    BITOP AND event:20250613-15 uv:20250613 uv:20250614 uv:20250615
    
    # 연속 출석자 수 확인
    BITCOUNT event:20250613-15
    ```

4. **HyperLogLog를 이용한 애플리케이션 미터링**

    **클라우드 환경에서의 미터링**은 요금을 측정하는 방법으로 중요합니다. 미터링 솔루션은 서비스 사용 내역을 이용하기 때문에 **대용량 처리**를 할 수 있어야 하며 규모에 따라 **초당 수천 건 이상의 작업**이 발생할 수 있습니다. 따라서 **높은 Throughput과 낮은 Latency**가 중요합니다.

    예를 들어 서버와 클라이언트에서 발생하는 로그를 수집하고 인덱싱해 사용자가 특정 로그를 검색하고 조회하는 서비스를 클라우드에서 제공한다면, 로그를 수집할 때마다 서비스의 API를 호출하고, **하나의 API 호출마다 건별로 과금**을 매기는 정책이라면 **사용자별 API 호출을 카운트**해야 합니다.

    Redis의 **HyperLogLog**는 아래와 같은 특징을 가지는 상황에서 사용할 수 있습니다:

    - **집합 내의 유일한 데이터 개수를 카운팅**해야 함
    - **1% 미만의 오차는 허용 가능**함  
    - **카운팅할 때 사용한 정확한 데이터를 다시 확인하지 않아도 됨**
  
    일반적으로는 중복을 피하기 위해서는 **저장된 데이터를 모두 기억**해야 합니다. 하지만 저장되는 데이터가 많을수록 많은 메모리를 사용합니다. 하지만 **저장된 값을 확인하지 않아도 되는 경우**라면 **HyperLogLog를 이용해서 최소한의 메모리만을 사용**해서 중복되지 않는 데이터의 개수를 계산할 수 있습니다. 

    **각 유저의 ID를 키로 사용**하고 API를 호출할 때마다 **로그의 식별자를 HyperLogLog에 저장**할 수 있습니다. 
    예를 들어 2025년 6월에 ID가 111인 유저의 호출 횟수를 계산하려면 **202506:user:111**이라는 키에 **PFADD** 명령어를 사용해 로그 식별자를 저장하면 됩니다.

    ```redis-cli
    PFADD 202506:user:111 45378
    -> (integer) 1
    PFADD 202506:user:111 32423
    -> (integer) 1
    PFADD 202506:user:111 45378 # 중복된 데이터
    -> (integer) 1

    # 중복되지 않은 데이터 개수 조회
    PFCOUNT 202506:user:111
    -> (integer) 2
    
    # 여러 달 데이터 병합
    PFMERGE 2025:user:111 202505:user:111 202506:user:111
    PFCOUNT 2025:user:111
    -> (integer) 1847
    ```

    **HyperLogLog**는 Set과 비슷하지만 **저장 용량이 12KB로 고정**되어 **효율적인 메모리 공간 활용**이 가능합니다.
    또한, **PFMERGE** 커맨드를 이용해 **여러 HyperLogLog 자료구조를 병합**할 수 있습니다. 이를 통해 **여러 날/월의 합산 데이터**를 쉽게 생성할 수 있습니다.

5. **Geospatial Index를 이용한 위치 기반 애플리케이션 개발**

    위치 데이터는 주로 **경도와 위도(x, y) 좌표 쌍**으로 표현됩니다. 특히 사용자의 위치가 **실시간으로 변할 때**에는 이러한 공간 데이터를 처리하는 저장소는 아래와 같은 기능을 가지고 있어야 합니다.

    - **사용자의 현재 위치 파악**
    - **사용자의 이동에 따른 실시간 변동 위치 업데이트**
    - **사용자의 위치를 기준으로 근처의 장소 검색**

    만약 **관계형 DB에서 위치 데이터를 처리**한다면 실제 데이터 가공 및 처리 과정은 **저장소 외부에서 이루어져야** 합니다. 그러나 **Redis를 활용**한다면 **실시간 위치 연산을 직접 수행**할 수 있어서 **I/O 비용과 애플리케이션 코드의 복잡성을 감소**시키는 효과를 가질 수 있습니다.

    또한, **Geo 기능을 다른 기능과 조합**하면 빠르고 효율적인 서비스를 구축할 수 있습니다. 예를 들어 **Geo Set과 Pub/Sub 기능**을 사용하여 특정 맛집에서 이벤트를 발생시킬 때에 **해당 지역 근처의 사용자에게 실시간 알림**을 보내는 서비스를 간단히 구축할 수 있습니다.

    **Geo Set**은 위치 공간 관리에 특화된 데이터 구조로, 각 위치 데이터는 **경도와 위도의 쌍으로 저장**되며 **내부적으로는 Sorted Set 구조**로 저장됩니다.

    ```redis-cli
    # 위치 데이터 추가
    GEOADD locations 126.9780 37.5665 "서울역"
    GEOADD locations 127.0276 37.4979 "강남역"
    GEOADD locations 126.9895 37.5512 "명동"
    
    # 특정 장소의 좌표 조회
    GEOPOS locations "서울역"
    -> 1) 1) "126.97799735069274902"
       2) "37.56649715308409073"
    
    # 두 지점 간의 거리 계산
    GEODIST locations "서울역" "강남역" km
    -> "6.1137"
    
    # 반경 내 장소 검색
    GEORADIUS locations 126.9780 37.5665 5 km WITHDIST
    -> 1) 1) "서울역"
       2) "0.0000"
       3) 1) "명동"
       2) "1.3821"
    
    # 특정 멤버 기준 반경 검색
    GEORADIUSBYMEMBER locations "서울역" 10 km WITHCOORD
    ```

    이러한 Geospatial 기능을 활용하면 **배달 서비스, 위치 기반 추천, 근처 매장 찾기** 등의 다양한 **LBS(Location Based Service)**를 효율적으로 구현할 수 있습니다. 


---

Reference

https://product.kyobobook.co.kr/detail/S000210785682