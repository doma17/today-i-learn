## 함수형 프로그래밍 with Java | 벤 바이디히 저자

- 해당 책을 읽고 개인적으로 공부하는 Repo입니다.
- https://product.kyobobook.co.kr/detail/S000212762854

---

### 개요

> 자바 8부터 도입된 Lambda, Stream API, Optional Class 등 함수형 프로그래밍에 대한 깊은 이해와 함수형 사고방식을 키우기 위한 책입니다.

---
### 주요 단어 메모

- SAM(Single Abstarct Method)
- 메모이제이션 (e.g. Map::computeIfAbscent)
- JavaBean
- POJO(Plain Old Java Object)
- effectively final
- 보일러 플레이트
- Stream API
- JMH
- 동시성과 병렬성의 차이
- 재귀적 분해
- ExectorService
- ForkJoinPool
- 동시 멀티스레딩(SMT) - 하이퍼스레딩
- 데이터 소스 분해
- NQ 모델
- 스레드 경쟁접근
- Thunk와 CAS알고리즘

---
### 기본 자바 함수형 인터페이스

- Function<T,R> : 인수를 받고 결과를 반환
- Consumer<T> : 인수만 받고 결과를 반환 X
- Supplier<R> : 인수를 받지 않고 결과만 반환
- Predicate<T\> : 인수를 받아서 표현식에 대해 테스트하고 boolean 값을 결과로 반환.

---
### Stream 파이프라인 기본 연산

모든 Stream 데이터 처리의 기본적인 구성 요소이다. map/filter/reduce 패턴은은 독립적인 함수의 조합으로 내부 반복을 활용하여, 제어문을 제거할 수 있게 해준다.

- Map : 데이터 변환
- Filter : 데이터 선택
- Reduce : 결과 도출

---
### 노트

- Record의 얕은 불변성 및 JavaBean과의 차이
- Record의 컴팩트 생성자
- Builder 패턴
- 빈 검증 API - @NonNUll, @Positive (JSR-380)
- Record : 명목상 튜플
- Record는 컴포넌트에 의해서만 정의되는 투명한 데이터 애그리게이터 타입니다.
- Record는 기존 클래스 방식보다 유연하고 안전한 직렬화 방식을 지원한다.
- 대부분의 스트림 중간연산은 상태를 갖지 않고, 독립적으로 작동한다.
- 하지만, limit, skip과 같은 중간연산들은 목적 수행을 위해 상태 값을 관리한다.
- 의도하지 않은 사이드 이펙트를 위한 코드를 줄이며 가능한 순수 함수로 설계하는 것이 바람직하다.
- 스트림은 지연성을 갖는다.
- 병렬 처리는 항상 최적의 방법은 아니며 검증이 필요하다.
- 스트림은 parallel 또는 sequential 메서드를 호출하여 실행 모드를 변경하면 파이프라인 내의 위치에 관계 없이 전체 스트림 파이프라인에 영향을 준다.
- 스트림 내에서 일부만 병렬, 순차 모드로 실행하는 것은 불가능하다.
- 스트림은 재귀적 분해 개념을 사용한다. (분할 정복)
- 스트림은 따로 명시적으로 ExectorService를 사용할 필요 없다. 내부적으로 ForkJoinPool을 활용한다.
- ForkJoinPool은 작업 훔치기 방식(자신의 할당 작업을 마치면 다른 스레드의 작업을 훔침)으로 스레드를 실행한다.
- 병렬 스트림을 사용하는 것은 다양한 요소에 영향을 받으며 항상 성능 향상을 보장하지 않는다.
- JVM은 (JSR-133) 메모리 접근 순서 병경이라는 최적화 기술을 사용하여 코드에서 정의된 순서와는 다르게 명령을 실행한다.
- 다중 스레드의 부적합한 메서드를 사용할 때에는 병렬 처리로 전환하는 것은 신중하게 결정해야 한다.
- 부적절하게 병렬 스트림을 사용하면 성능이 저하될 수 있다.
- 기본적으로 순차 스트림을 사용하고, 성능 향상이 요구되고 에측되는 상황에서만 병렬 스트림으로 전환해야 한다.
- 람다 표현식에서는 일반적인 try-catch문만 사용가능하다. 
- Optional은 스트림에서 flatMap(Optional::Stream)을 통해서 간결하게 실행할 수 있다.
- Optional은 직렬화가 되지 않기 때문에 getter 반환값으로 Optional을 사용해라.
- Try<T, R>는 고차 함수에 대한 Stream 예외 처리를 함수형 방식으로 다루기 위한 래퍼 타입이다.
- Try는 success, failure 두 가지 상태를 가지며, success는 성공 결과 타입인 R을 포함하고, failure는 Exception을 포함한다.
- JVM에서는 메서드 인수들을 항상 값으로 전달한다. 원시 타입이 아닌 경우 reference라는 타입을 사용하여 객체 핸들을 전달한다.
- 엄격성은 '일을 하는 것'에 중점을 두고, 느긋함은 '할 일을 고려하는 것'에 대한 것이다.
- CompletableFuture를 통해 비동기 스레드 사용을 함수형태로 이끌어 낼 수 있다.
- 

---

### 기록
 - 2025.03.17 - 98p
 - 2025.03.18 - 152p
 - 2025.03.19 - 204p
 - 2025.03.20 - 240p
 - 2025.03.21 - 266p
 - 2025.03.22 - 312p
 - 2025.03.24 - 343p
 - 2025.03.25 - 396p
 - 2025.03.26 - 446p
 - 2025.03.30 - 485p