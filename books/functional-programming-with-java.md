## 함수형 프로그래밍 with Java | 벤 바이디히 저자

![img함수형프로그래밍](/img/함수형프로그래밍책표지.jpg)

- 해당 책을 읽고 개인적으로 공부한 흔적입니다.
- https://product.kyobobook.co.kr/detail/S000212762854

---

### 개요

> 자바 8부터 도입된 Lambda, Stream API, Optional Class 등 함수형 프로그래밍에 대한 깊은 이해와 함수형 사고방식을 키우기 위한 책입니다.

---

### 감상문

이 책을 통해 Java 8 이후의 함수형 프로그래밍 패러다임을 깊이 있게 학습할 수 있었다. 특히 기존의 명령형 프로그래밍에서 선언적 프로그래밍으로의 사고 전환이 가장 인상 깊었다.

**주요 깨달음:**

1. **함수형 사고의 전환**: Stream API를 통한 map/filter/reduce 패턴은 단순히 새로운 문법이 아니라, 데이터 처리에 대한 근본적인 접근 방식의 변화임을 깨달았다. 반복문 대신 파이프라인으로 사고하는 것이 코드의 가독성과 유지보수성을 크게 향상시킨다.

2. **성능에 대한 균형적 시각**: 병렬 스트림이 항상 성능 향상을 보장하지 않는다는 점이 특히 중요했다. "기본적으로 순차 스트림을 사용하고, 성능 향상이 예측되는 상황에서만 병렬 스트림으로 전환"하라는 조언은 실무에서 매우 유용할 것 같다.

3. **불변성의 가치**: Record 클래스와 불변 객체의 개념을 통해 동시성 프로그래밍에서의 안전성을 확보할 수 있다는 점이 인상적이었다. 특히 "불변성을 적용시키는 것은 어렵지만, 해제시키는 건 쉽다"는 표현이 기억에 남는다.

4. **실용적 접근**: 브라이언 게츠의 "더 나은 프로그래머가 되세요"라는 조언처럼, OOP와 FP를 대립적으로 보지 않고 상황에 맞게 활용하는 것이 중요함을 배웠다.

**실무 적용 계획:**
- Optional을 활용한 null 안전성 확보
- Stream API를 통한 컬렉션 처리 개선
- 함수형 인터페이스를 활용한 코드의 재사용성 증대
- CompletableFuture를 통한 비동기 처리 개선

이 책은 Java 개발자라면 반드시 읽어야 할 필독서라고 생각한다. 단순히 새로운 기능을 익히는 것을 넘어서, 더 나은 코드를 작성하는 사고방식을 기를 수 있는 귀중한 경험이었다.

---
### 주요 단어 메모

- SAM(Single Abstarct Method)
- 메모이제이션 (e.g. Map::computeIfAbscent)
- JavaBean
- POJO(Plain Old Java Object)
- effectively final
- 보일러 플레이트
- Stream API
- JMH
- 동시성과 병렬성의 차이
- 재귀적 분해
- ExectorService
- ForkJoinPool
- CompletableFuture
- 동시 멀티스레딩(SMT) - 하이퍼스레딩
- 데이터 소스 분해
- NQ 모델
- 스레드 경쟁접근
- Thunk와 CAS알고리즘
- FC/IS 아키텍처

---
### 기본 자바 함수형 인터페이스

- Function<T,R> : 인수를 받고 결과를 반환
- Consumer<T> : 인수만 받고 결과를 반환 X
- Supplier<R> : 인수를 받지 않고 결과만 반환
- Predicate<T\> : 인수를 받아서 표현식에 대해 테스트하고 boolean 값을 결과로 반환.

---
### Stream 파이프라인 기본 연산

모든 Stream 데이터 처리의 기본적인 구성 요소이다. map/filter/reduce 패턴은은 독립적인 함수의 조합으로 내부 반복을 활용하여, 제어문을 제거할 수 있게 해준다.

- Map : 데이터 변환
- Filter : 데이터 선택
- Reduce : 결과 도출

---
### 노트

- Record의 얕은 불변성 및 JavaBean과의 차이
- Record의 컴팩트 생성자
- Builder 패턴
- 빈 검증 API - @NonNUll, @Positive (JSR-380)
- Record : 명목상 튜플
- Record는 컴포넌트에 의해서만 정의되는 투명한 데이터 애그리게이터 타입니다.
- Record는 기존 클래스 방식보다 유연하고 안전한 직렬화 방식을 지원한다.
- 대부분의 스트림 중간연산은 상태를 갖지 않고, 독립적으로 작동한다.
- 하지만, limit, skip과 같은 중간연산들은 목적 수행을 위해 상태 값을 관리한다.
- 의도하지 않은 사이드 이펙트를 위한 코드를 줄이며 가능한 순수 함수로 설계하는 것이 바람직하다.
- 스트림은 지연성을 갖는다.
- 병렬 처리는 항상 최적의 방법은 아니며 검증이 필요하다.
- 스트림은 parallel 또는 sequential 메서드를 호출하여 실행 모드를 변경하면 파이프라인 내의 위치에 관계 없이 전체 스트림 파이프라인에 영향을 준다.
- 스트림 내에서 일부만 병렬, 순차 모드로 실행하는 것은 불가능하다.
- 스트림은 재귀적 분해 개념을 사용한다. (분할 정복)
- 스트림은 따로 명시적으로 ExectorService를 사용할 필요 없다. 내부적으로 ForkJoinPool을 활용한다.
- ForkJoinPool은 작업 훔치기 방식(자신의 할당 작업을 마치면 다른 스레드의 작업을 훔침)으로 스레드를 실행한다.
- 병렬 스트림을 사용하는 것은 다양한 요소에 영향을 받으며 항상 성능 향상을 보장하지 않는다.
- JVM은 (JSR-133) 메모리 접근 순서 병경이라는 최적화 기술을 사용하여 코드에서 정의된 순서와는 다르게 명령을 실행한다.
- 다중 스레드의 부적합한 메서드를 사용할 때에는 병렬 처리로 전환하는 것은 신중하게 결정해야 한다.
- 부적절하게 병렬 스트림을 사용하면 성능이 저하될 수 있다.
- 기본적으로 순차 스트림을 사용하고, 성능 향상이 요구되고 에측되는 상황에서만 병렬 스트림으로 전환해야 한다.
- 람다 표현식에서는 일반적인 try-catch문만 사용가능하다. 
- Optional은 스트림에서 flatMap(Optional::Stream)을 통해서 간결하게 실행할 수 있다.
- Optional은 직렬화가 되지 않기 때문에 getter 반환값으로 Optional을 사용해라.
- Try<T, R>는 고차 함수에 대한 Stream 예외 처리를 함수형 방식으로 다루기 위한 래퍼 타입이다.
- Try는 success, failure 두 가지 상태를 가지며, success는 성공 결과 타입인 R을 포함하고, failure는 Exception을 포함한다.
- JVM에서는 메서드 인수들을 항상 값으로 전달한다. 원시 타입이 아닌 경우 reference라는 타입을 사용하여 객체 핸들을 전달한다.
- 엄격성은 '일을 하는 것'에 중점을 두고, 느긋함은 '할 일을 고려하는 것'에 대한 것이다.
- CompletableFuture를 통해 비동기 스레드 사용을 함수형태로 이끌어 낼 수 있다.
- 바인딩 되지 않은 비정적 메서드 참조에는 String::toLowerCase가 있다. 특정 인스턴스에 바인딩 되지 않고 타입 자체를 통해 참조 되기 때문에 람다는 첫 번째 인수로 해당 타입을 받아 들인다.
- toLowerCase는 Fuction<String, String>으로 간주되기에, 함수형 인터페이스를 활용해 객체의 메서드를 참조할 때 유용하다.
- 불변성을 통해서 병렬성과 동시성을 쉽게 다룰 수 있게된다.
- 불변성이 적용된 상황을 해제시키는 건 쉽지만, 불변성을 적용시키는 것은 어렵다.
- 순수함수는 사이드 이펙트가 없고, 입력에만 의존한다.
- 함수형 프로그래밍은 잘못사용하면 잠재적인 오버헤드를 만들 수 있다.
- OOP와 FP는 근본적으로 다르지만 대부분의 개념이 서로 베타적이거나 독립적이지 않다. 그냥 접근 방식이 다를 뿐이다.
- 함수형 사고방식은 순수 함수를 활용해 사이드 이펙트를 방지하거나 불변성을 채택하는 것과 같이 작은 것부터 시작이다.

---

켄트 백
> '먼저 작동하게 만들라. 그 다음 올바르게 수정하고, 마지막으로 빠르게 만들어라.'

Oracle Java 브라이언 게츠 
> '함수형 프로그래머가 되지 마세요. 객체 지향 프로그래머가 되지 마세요. 더 나은 프로그래머가 되세요.'

---

### 기록
 - 2025.03.17 - 98p
 - 2025.03.18 - 152p
 - 2025.03.19 - 204p
 - 2025.03.20 - 240p
 - 2025.03.21 - 266p
 - 2025.03.22 - 312p
 - 2025.03.24 - 343p
 - 2025.03.25 - 396p
 - 2025.03.26 - 446p
 - 2025.03.30 - 485p
 - 2025.03.31 - 522p